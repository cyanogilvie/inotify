# vim: ft=tcl foldmethod=marker foldmarker=<<<,>>> ts=4 shiftwidth=4

itcl::class inotify::Queue {
	constructor {args} {}
	destructor {}

	public {
		variable cb

		method add_watch {path {mask {IN_ALL_EVENTS}}}
		method rm_watch {path}
	}

	private {
		variable queue_handle
		variable wd_map
		variable path_map
		variable tcl85

		method readable {}
	}
}


itcl::body inotify::Queue::constructor {args} { #<<<
	array set wd_map	{}
	array set path_map	{}

	eval configure $args

	set tcl85	[package vsatisfies [info patchlevel] 8.5]

	set queue_handle	[inotify::create_queue]
	fconfigure $queue_handle \
			-blocking 0 \
			-buffering none \
			-translation binary \
			-encoding binary
	fileevent $queue_handle readable [itcl::code $this readable]
}

#>>>
itcl::body inotify::Queue::destructor {} { #<<<
	if {[info exists queue_handle]} {
		foreach {wd path} [array get wd_map] {
			if {[catch {
				inotify::rm_watch $queue_handle $wd
			} errmsg]} {
				puts stderr "Error removing watch on \"$path\": $errmsg"
			}
			array unset wd_map $wd
		}
		if {[catch {
			close $queue_handle
		} errmsg]} {
			puts stderr "Error closing inotify queue handle: $errmsg"
		}
	}
}

#>>>
itcl::body inotify::Queue::add_watch {path {mask {IN_ALL_EVENTS}}} { #<<<
	set wd	[inotify::add_watch $queue_handle $path $mask]
	set path_map($path)	$wd
	set wd_map($wd)		$path
}

#>>>
itcl::body inotify::Queue::rm_watch {path} { #<<<
	if {![info exists path_map($path)]} {
		error "No watches on path \"$path\"" "" [list no_watches $path]
	}
	inotify::rm_watch $queue_handle $path_map($path)
	array unset path_map $path
	array unset wd_map $wd
}

#>>>
itcl::body inotify::Queue::readable {} { #<<<
	if {[eof $queue_handle]} {
		puts stderr "Queue handle closed"
		close $queue_handle
		unset queue_handle
		itcl::delete object $this
		return
	}

	set dat	[read $queue_handle]
	set events	[inotify::decode_events $dat]

	foreach event $events {
		set wd	[lindex $event 0]
		if {$wd == -1} {
			# This happens when we get a synthetic IN_Q_OVERFLOW event
			set event	[lreplace $event 0 0 {}]
		} elseif {![info exists wd_map($wd)]} {
			puts stderr "No path map for watch descriptor ($wd)"
			continue
		} else {
			set event	[lreplace $event 0 0 $wd_map($wd)]
		}

		set arr	{}
		foreach field {path mask cookie name} value $event {
			lappend arr $field $value
		}

		if {[info exists cb]} {
			if {[catch {
				#if {$tcl85} {
				#	uplevel #0 [list {*}$cb $arr]
				#} else {
				#	uplevel #0 $cb [list [lrange $arr 0 end]]
				#}
				uplevel #0 $cb [list [lrange $arr 0 end]]
			} errmsg]} {
				puts stderr "Error invoking callback for event ($arr): $errmsg\n$::errorInfo"
			}
		}
	}
}

#>>>
